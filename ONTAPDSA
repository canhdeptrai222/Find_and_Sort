/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>
#include <ctime>
#include <cstring>
#include <string>
#define MAX 100
using namespace std;

void inputArray(int a[], int& n) {
	for(int i = 0; i < n; i++) {
		a[i] = rand() % 100 + 1;
	}
}
void outputArray(int a[], const int n) {
	cout << "Cac phan tu cua mang: ";
	for(int i = 0; i < n; i++) {
		cout << a[i] << " ";
	}
	cout << endl;
}

int search(int a[], int n, int x) {
	for(int i = 0; i < n; i++) {
		if(x == a[i])
			return i;
	}
	return -1;
}
void addNum(int a[], int& n, int x) {
	if(n == MAX)
		return;
	if(n == 0)
		a[0] = x;
	else {
		a[n] = x;
	}
	n++;
}
void delLastElement(int a[], int& n) {
	a[n - 1] = -1;
	n--;
}
void delElement(int a[], int&n, int index) {
	for(int i = index ; i < n; i++ ) {
		a[i] = a[i+ 1];
	}
	n--;
}
void addElementByIndex(int a[], int&n, int index, int x) {
	for(int i = n -1; i >= index; i--) {
		a[i + 1] = a[i];
	}
	a[index] = x;
	n++;
}
int findMax(int a[], int n) {
	int max = a[0];
	for(int i = 1; i < n; i++) {
		if(max < a[i])
			max = a[i];
	}
	return max;
}
int findSecondMax(int a[], int n) {
	int FirstMax = a[0];
	int SecondMax = a[0];
	for(int i = 1; i < n; i++) {
		if(a[i] > FirstMax) {
			SecondMax = FirstMax;
			FirstMax = a[i];
		}
		else if(a[i] > SecondMax)
			SecondMax= a[i];
	}
	return SecondMax;
}
void swap(int &a, int &b) {
	int c = a;
	a = b;
	b =c;
}
void selectionSort(int a[], int n) {
	for(int i = 0; i < n -1; i++) {
		int index = i;
		for(int j = i + 1; j < n; j++) {
			if(a[index] < a[j])
				index = j;
		}
		swap(a[i], a[index]);
	}
}
void insertionSort(int a[], int n) {
	for(int i = 1; i < n- 1; i++) {
		int x = a[i];
		int j = i - 1;
		while(j >= 0 && x >= a[j]) {
			a[j+1] = a[j];
			j--;
		}
		a[j + 1] = x;
	}
}

void bubbleSort(int a[], int n) {
	for(int i = 0; i < n- 1; i++) {
		for(int j = 0; j < n - i -1; j++) {
			if(a[j] < a[j+1])
				swap(a[j], a[j+1]);
		}
	}
}

void interchangeSort(int a[], int n) {
	for(int i = 0; i < n -1 ; i++) {
		for(int j = i + 1; j < n; j++) {
			if(a[i] < a[j])
				swap(a[i], a[j]);
		}
	}
}

void quickSortWithRecursion(int a[], int left, int right ) {
	int pivot = (left + right) / 2;
	int l = left;
	int r = right;
	while(l <= r) {
		while(a[l] > a[pivot])
			l++;
		while(a[r] < a[pivot])
			r--;
		if(l <= r) {
			swap(a[l], a[r]);
			l++;
			r--;
		}
		if(left < r)
			quickSortWithRecursion(a, left, r);
		if(right > l)
			quickSortWithRecursion(a, l, right);
	}
}

int binarySearch(int a[], int n, int x){
    int left = 0; int right = n -1;
    int mid;
    while(left <= right){
        mid = (left + right) / 2;
        if(a[mid] == x)
        return mid;
        else if(x > a[mid])
        right = mid - 1;
        else if(x < a[mid])
        left = mid + 1;
    }
    return -1;
}

struct SinhVien{
    string hoTen;
    int mssv;
};

struct Node {
	int value;
	Node* left;
	Node* right;
};

void init(Node*& root) {
	root = NULL;
}

Node* createNode(int x) {
	Node* p = new Node;
	p->value = x;
	p->left = p->right = NULL;
	return p;
}
void addNode(Node*& root, int x) {
	if(root == NULL)
		root = createNode(x);
	if(x == root->value)
		return;
	if(x > root->value)
		addNode(root->right, x);
	else if(x < root->value)
		addNode(root->left, x);

}

void searchLeftNode(Node*& p, Node*& q) {
	if(q->left == NULL) {
		p->value = q->value;
		p = q;
		q = q->right;
	}
	else
		searchLeftNode(p, q->left);
}
void delNode(Node*& root, int x) {
	if(root == NULL)
		return;
	if(x == root->value) {
		Node* p = root;
		if(root->right == NULL)
			root= root->left;
		else if(root->left == NULL)
			root=root->right;
		else {
			searchLeftNode(p, root->right);
		}
		delete p;
		p= NULL;
		return;
	}
	if(x > root->value)
		delNode(root->right, x);
	else if(x < root->value)
		delNode(root->left, x);
}
struct Stack {
	Node* a[MAX];
	int top;
};
void init(Stack &s) {
	s.top = -1;
}
void push(Stack& s, Node* x) {
	s.a[++s.top] = x;
}
Node* geek(Stack s) {
	return s.a[s.top];
}
void pop(Stack& s) {
	s.a[s.top--];
}
bool isEmpty(Stack s) {
	return s.top == -1;
}
struct NodeQueue{
    Node* value;
    NodeQueue* next;
};
void init(NodeQueue*& q){
    q = NULL;
}
bool isEmpty(NodeQueue* q){
    return q == NULL;
}
NodeQueue* createNodeQueue(Node* x){
    NodeQueue* p = new NodeQueue;
    p->value = x;
    p->next = NULL;
    return p;
}
void enQueue(NodeQueue*& head, Node* x){
    if(head == NULL)
    head = createNodeQueue(x);
    else{
        NodeQueue* p = createNodeQueue(x);
        NodeQueue* q = head;
        while(q-> next != NULL){
            q = q->next;
        }
        q->next = p;
    }
}
Node* deQueue(NodeQueue*& head){
    if(head != NULL){
        NodeQueue* p = head;
        head = head->next;
        p->next = NULL;
        return p->value;
    }
}
void LNR(Node* root) {
	if(root != NULL) {
		LNR(root->left);
		cout << root->value << " ";
		LNR(root->right);
	}
}
void LRN(Node* root) {
	if(root != NULL) {
		LRN(root->left);
		LRN(root->right);
		cout << root->value << " ";
	}
}
void NLR(Node* root) {
	if(root != NULL) {
		cout << root->value << " ";
		NLR(root->left);
		NLR(root->right);
	}
}
void lnrNoRecursion(Node* root) {
	Stack s;
	init(s);
	Node* cur = root;
	while(cur != NULL || !isEmpty(s)) {
		if(cur!= NULL) {
			push(s,cur);
			cur=cur->left;
		} else {
			cout << geek(s)->value << " ";
			cur = geek(s)->right;
			pop(s);
		}
	}
}
void lrn2Stack(Node* root) {
	Stack s1,s2;
	init(s1);
	init(s2);
	push(s1, root);
	while(!isEmpty(s1)) {
		Node* cur = geek(s1);
		pop(s1);
		push(s2, cur);
		if(cur->left != NULL)
			push(s1, cur->left);
		if(cur->right != NULL)
			push(s1, cur->right);
	}
	while(!isEmpty(s2)) {
		cout << geek(s2)->value << " ";
		pop(s2);
	}
}
void lrn1Stack(Node* root) {
	Stack s;
	init(s);
	Node* cur = root;
	while(true) {
		if(cur != NULL) {
			push(s, cur);
			cur = cur->left;
		} else {
			if(isEmpty(s))
				break;
			if(geek(s)->right == NULL) {
				cout << geek(s) ->value << " ";
				cur = geek(s);
				pop(s);
				while(geek(s)->right == cur) {
					cout << geek(s)->value << " ";
					cur = geek(s);
					pop(s);
					if(isEmpty(s))
						break;
				}
			}
			if(!isEmpty(s))
			cur = geek(s)->right;
			else
			cur = NULL;
		}
	}
}
void nlrNoRecursion(Node* root) {
	Stack s;
	init(s);
	push(s, root);
	Node* cur = NULL;
	while(!isEmpty(s)) {
		cur = geek(s);
		cout << cur->value << " ";
		pop(s);
		if(cur->right != NULL)
			push(s, cur->right);
		if(cur->left != NULL)
			push(s, cur->left);
	}
}
void displayTreeQueue(Node* root){
    NodeQueue* q;
    init(q);
    enQueue(q, root);
    Node* cur = NULL;
    while(!isEmpty(q)){
        cur = deQueue(q);
        cout << cur->value << " ";
        if(cur->left != NULL)
        enQueue(q, cur->left);
        if(cur->right != NULL)
        enQueue(q, cur->right);
    }
}


int main()
{
    

	return 0;
}
